// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: api/keyquarry.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// KeyQuarryClient is the client API for KeyQuarry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeyQuarryClient interface {
	// Set sets a key/value pair. If the key already exists,
	// it will be updated. If the key already exists and is
	// locked, an error will be returned. If the key already
	// exists and is expired (and not locked), it will be deleted
	// and created as new.
	Set(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*SetResponse, error)
	// Get returns the value of a key. If the key does not exist,
	// an error will be returned.
	Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*GetResponse, error)
	// Inspect returns metadata about a key. If the key does not
	// exist, an error will be returned.
	Inspect(ctx context.Context, in *InspectRequest, opts ...grpc.CallOption) (*InspectResponse, error)
	// Delete deletes a key. If the key does not exist, an error
	// will be returned. If the key is locked, an error will
	// be returned.
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// Exists indicates whether a key exists.
	Exists(ctx context.Context, in *Key, opts ...grpc.CallOption) (*ExistsResponse, error)
	// Pop returns the value of a key and deletes it. If the key
	// is locked or doesn't exist, an error will be returned.
	Pop(ctx context.Context, in *PopRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Clear deletes all unlocked keys from the store.
	Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*ClearResponse, error)
	// ListKeys returns a list of keys matching a pattern.
	ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error)
	// Stats returns statistics about the store.
	Stats(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ServerMetrics, error)
	// ClearHistory deletes all history entries for unlocked keys.
	ClearHistory(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ClearHistoryResponse, error)
	// Lock locks a key for a given duration. If the key is already locked, an
	// error will be returned. If no duration is provided, the lock will not
	// expire.
	Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error)
	// Unlock unlocks a key. If the key is not locked, nothing will happen.
	Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error)
	// GetRevision gets the value of a key at a specific revision, with
	// its timestamp
	GetRevision(ctx context.Context, in *GetRevisionRequest, opts ...grpc.CallOption) (*RevisionResponse, error)
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	SetReadOnly(ctx context.Context, in *ReadOnlyRequest, opts ...grpc.CallOption) (*ReadOnlyResponse, error)
	WatchStream(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (KeyQuarry_WatchStreamClient, error)
	GetKeyMetric(ctx context.Context, in *KeyMetricRequest, opts ...grpc.CallOption) (*KeyMetric, error)
	WatchKeyValue(ctx context.Context, in *WatchKeyValueRequest, opts ...grpc.CallOption) (KeyQuarry_WatchKeyValueClient, error)
}

type keyQuarryClient struct {
	cc grpc.ClientConnInterface
}

func NewKeyQuarryClient(cc grpc.ClientConnInterface) KeyQuarryClient {
	return &keyQuarryClient{cc}
}

func (c *keyQuarryClient) Set(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*SetResponse, error) {
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Inspect(ctx context.Context, in *InspectRequest, opts ...grpc.CallOption) (*InspectResponse, error) {
	out := new(InspectResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Inspect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Exists(ctx context.Context, in *Key, opts ...grpc.CallOption) (*ExistsResponse, error) {
	out := new(ExistsResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Pop(ctx context.Context, in *PopRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Pop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*ClearResponse, error) {
	out := new(ClearResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Clear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error) {
	out := new(ListKeysResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/ListKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Stats(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ServerMetrics, error) {
	out := new(ServerMetrics)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Stats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) ClearHistory(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ClearHistoryResponse, error) {
	out := new(ClearHistoryResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/ClearHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error) {
	out := new(LockResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Lock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error) {
	out := new(UnlockResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Unlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) GetRevision(ctx context.Context, in *GetRevisionRequest, opts ...grpc.CallOption) (*RevisionResponse, error) {
	out := new(RevisionResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/GetRevision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) SetReadOnly(ctx context.Context, in *ReadOnlyRequest, opts ...grpc.CallOption) (*ReadOnlyResponse, error) {
	out := new(ReadOnlyResponse)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/SetReadOnly", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) WatchStream(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (KeyQuarry_WatchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &KeyQuarry_ServiceDesc.Streams[0], "/keyquarry.KeyQuarry/WatchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &keyQuarryWatchStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KeyQuarry_WatchStreamClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type keyQuarryWatchStreamClient struct {
	grpc.ClientStream
}

func (x *keyQuarryWatchStreamClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keyQuarryClient) GetKeyMetric(ctx context.Context, in *KeyMetricRequest, opts ...grpc.CallOption) (*KeyMetric, error) {
	out := new(KeyMetric)
	err := c.cc.Invoke(ctx, "/keyquarry.KeyQuarry/GetKeyMetric", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyQuarryClient) WatchKeyValue(ctx context.Context, in *WatchKeyValueRequest, opts ...grpc.CallOption) (KeyQuarry_WatchKeyValueClient, error) {
	stream, err := c.cc.NewStream(ctx, &KeyQuarry_ServiceDesc.Streams[1], "/keyquarry.KeyQuarry/WatchKeyValue", opts...)
	if err != nil {
		return nil, err
	}
	x := &keyQuarryWatchKeyValueClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KeyQuarry_WatchKeyValueClient interface {
	Recv() (*WatchKeyValueResponse, error)
	grpc.ClientStream
}

type keyQuarryWatchKeyValueClient struct {
	grpc.ClientStream
}

func (x *keyQuarryWatchKeyValueClient) Recv() (*WatchKeyValueResponse, error) {
	m := new(WatchKeyValueResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KeyQuarryServer is the server API for KeyQuarry service.
// All implementations must embed UnimplementedKeyQuarryServer
// for forward compatibility
type KeyQuarryServer interface {
	// Set sets a key/value pair. If the key already exists,
	// it will be updated. If the key already exists and is
	// locked, an error will be returned. If the key already
	// exists and is expired (and not locked), it will be deleted
	// and created as new.
	Set(context.Context, *KeyValue) (*SetResponse, error)
	// Get returns the value of a key. If the key does not exist,
	// an error will be returned.
	Get(context.Context, *Key) (*GetResponse, error)
	// Inspect returns metadata about a key. If the key does not
	// exist, an error will be returned.
	Inspect(context.Context, *InspectRequest) (*InspectResponse, error)
	// Delete deletes a key. If the key does not exist, an error
	// will be returned. If the key is locked, an error will
	// be returned.
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// Exists indicates whether a key exists.
	Exists(context.Context, *Key) (*ExistsResponse, error)
	// Pop returns the value of a key and deletes it. If the key
	// is locked or doesn't exist, an error will be returned.
	Pop(context.Context, *PopRequest) (*GetResponse, error)
	// Clear deletes all unlocked keys from the store.
	Clear(context.Context, *ClearRequest) (*ClearResponse, error)
	// ListKeys returns a list of keys matching a pattern.
	ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error)
	// Stats returns statistics about the store.
	Stats(context.Context, *EmptyRequest) (*ServerMetrics, error)
	// ClearHistory deletes all history entries for unlocked keys.
	ClearHistory(context.Context, *EmptyRequest) (*ClearHistoryResponse, error)
	// Lock locks a key for a given duration. If the key is already locked, an
	// error will be returned. If no duration is provided, the lock will not
	// expire.
	Lock(context.Context, *LockRequest) (*LockResponse, error)
	// Unlock unlocks a key. If the key is not locked, nothing will happen.
	Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error)
	// GetRevision gets the value of a key at a specific revision, with
	// its timestamp
	GetRevision(context.Context, *GetRevisionRequest) (*RevisionResponse, error)
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	SetReadOnly(context.Context, *ReadOnlyRequest) (*ReadOnlyResponse, error)
	WatchStream(*WatchRequest, KeyQuarry_WatchStreamServer) error
	GetKeyMetric(context.Context, *KeyMetricRequest) (*KeyMetric, error)
	WatchKeyValue(*WatchKeyValueRequest, KeyQuarry_WatchKeyValueServer) error
	mustEmbedUnimplementedKeyQuarryServer()
}

// UnimplementedKeyQuarryServer must be embedded to have forward compatible implementations.
type UnimplementedKeyQuarryServer struct {
}

func (UnimplementedKeyQuarryServer) Set(context.Context, *KeyValue) (*SetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedKeyQuarryServer) Get(context.Context, *Key) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedKeyQuarryServer) Inspect(context.Context, *InspectRequest) (*InspectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Inspect not implemented")
}
func (UnimplementedKeyQuarryServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedKeyQuarryServer) Exists(context.Context, *Key) (*ExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedKeyQuarryServer) Pop(context.Context, *PopRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pop not implemented")
}
func (UnimplementedKeyQuarryServer) Clear(context.Context, *ClearRequest) (*ClearResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedKeyQuarryServer) ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKeys not implemented")
}
func (UnimplementedKeyQuarryServer) Stats(context.Context, *EmptyRequest) (*ServerMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stats not implemented")
}
func (UnimplementedKeyQuarryServer) ClearHistory(context.Context, *EmptyRequest) (*ClearHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearHistory not implemented")
}
func (UnimplementedKeyQuarryServer) Lock(context.Context, *LockRequest) (*LockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedKeyQuarryServer) Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedKeyQuarryServer) GetRevision(context.Context, *GetRevisionRequest) (*RevisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRevision not implemented")
}
func (UnimplementedKeyQuarryServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedKeyQuarryServer) SetReadOnly(context.Context, *ReadOnlyRequest) (*ReadOnlyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetReadOnly not implemented")
}
func (UnimplementedKeyQuarryServer) WatchStream(*WatchRequest, KeyQuarry_WatchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchStream not implemented")
}
func (UnimplementedKeyQuarryServer) GetKeyMetric(context.Context, *KeyMetricRequest) (*KeyMetric, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyMetric not implemented")
}
func (UnimplementedKeyQuarryServer) WatchKeyValue(*WatchKeyValueRequest, KeyQuarry_WatchKeyValueServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchKeyValue not implemented")
}
func (UnimplementedKeyQuarryServer) mustEmbedUnimplementedKeyQuarryServer() {}

// UnsafeKeyQuarryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeyQuarryServer will
// result in compilation errors.
type UnsafeKeyQuarryServer interface {
	mustEmbedUnimplementedKeyQuarryServer()
}

func RegisterKeyQuarryServer(s grpc.ServiceRegistrar, srv KeyQuarryServer) {
	s.RegisterService(&KeyQuarry_ServiceDesc, srv)
}

func _KeyQuarry_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Set(ctx, req.(*KeyValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Get(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Inspect(ctx, req.(*InspectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Exists(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Pop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Pop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Pop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Pop(ctx, req.(*PopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Clear(ctx, req.(*ClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).ListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/ListKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).ListKeys(ctx, req.(*ListKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Stats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Stats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Stats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Stats(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_ClearHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).ClearHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/ClearHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).ClearHistory(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Lock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Lock(ctx, req.(*LockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Unlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Unlock(ctx, req.(*UnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_GetRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRevisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).GetRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/GetRevision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).GetRevision(ctx, req.(*GetRevisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_SetReadOnly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadOnlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).SetReadOnly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/SetReadOnly",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).SetReadOnly(ctx, req.(*ReadOnlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_WatchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KeyQuarryServer).WatchStream(m, &keyQuarryWatchStreamServer{stream})
}

type KeyQuarry_WatchStreamServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type keyQuarryWatchStreamServer struct {
	grpc.ServerStream
}

func (x *keyQuarryWatchStreamServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _KeyQuarry_GetKeyMetric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMetricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyQuarryServer).GetKeyMetric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keyquarry.KeyQuarry/GetKeyMetric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyQuarryServer).GetKeyMetric(ctx, req.(*KeyMetricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyQuarry_WatchKeyValue_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchKeyValueRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KeyQuarryServer).WatchKeyValue(m, &keyQuarryWatchKeyValueServer{stream})
}

type KeyQuarry_WatchKeyValueServer interface {
	Send(*WatchKeyValueResponse) error
	grpc.ServerStream
}

type keyQuarryWatchKeyValueServer struct {
	grpc.ServerStream
}

func (x *keyQuarryWatchKeyValueServer) Send(m *WatchKeyValueResponse) error {
	return x.ServerStream.SendMsg(m)
}

// KeyQuarry_ServiceDesc is the grpc.ServiceDesc for KeyQuarry service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeyQuarry_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "keyquarry.KeyQuarry",
	HandlerType: (*KeyQuarryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _KeyQuarry_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _KeyQuarry_Get_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _KeyQuarry_Inspect_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _KeyQuarry_Delete_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _KeyQuarry_Exists_Handler,
		},
		{
			MethodName: "Pop",
			Handler:    _KeyQuarry_Pop_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _KeyQuarry_Clear_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _KeyQuarry_ListKeys_Handler,
		},
		{
			MethodName: "Stats",
			Handler:    _KeyQuarry_Stats_Handler,
		},
		{
			MethodName: "ClearHistory",
			Handler:    _KeyQuarry_ClearHistory_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _KeyQuarry_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _KeyQuarry_Unlock_Handler,
		},
		{
			MethodName: "GetRevision",
			Handler:    _KeyQuarry_GetRevision_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _KeyQuarry_Register_Handler,
		},
		{
			MethodName: "SetReadOnly",
			Handler:    _KeyQuarry_SetReadOnly_Handler,
		},
		{
			MethodName: "GetKeyMetric",
			Handler:    _KeyQuarry_GetKeyMetric_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchStream",
			Handler:       _KeyQuarry_WatchStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchKeyValue",
			Handler:       _KeyQuarry_WatchKeyValue_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/keyquarry.proto",
}
